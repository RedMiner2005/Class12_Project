from utils import *


class Backend:
    """The backend services"""
    def __init__(self, error_handler):
        """Initialization for the backend services
        
        :param error_handler: The function of the Interface class that handles errors
        """
        self.error_handler = error_handler
        self.vote_file_name = ""
        self.candidates = {}
        self._codec = RSCodec(160)
        
        if not ensure_dir(cand_path):
            debug("Candidates path created")
        if not ensure_dir(vote_path):
            debug("Vote path created")
    
    def encrypt(self, key: bytes, data: dict) -> bytes:
        """Encrypts the data and encodes it using the RS algorithm.
        
        :param key: The encryption key
        :param data: The data to encrypt
        :returns: The encrypted data
        """
        f = Fernet(key)
        return self._codec.encode(f.encrypt(pickle.dumps(data)))
    
    def decrypt(self, key: bytes, data: bytes) -> dict:
        """Decrypts the data and decodes it using the RS algorithm.
        
        :param key: The encryption key
        :param data: The data to decrypt
        :returns: The decrypted data
        """
        f = Fernet(key)
        try:
            return pickle.loads(f.decrypt(bytes(self._codec.decode(data)[0])))
        except Exception as e:
            self.error_handler(e)
            return {}
    
    def verify_pin(self, pin) -> bool:
        """Verifies whether the PIN matches the stored hash
        
        :param pin: The input PIN
        :returns: Whether the PIN is correct or not
        """
        try:
            return self.candidates[pin_key] == get_pin_hash(pin)
        except Exception as e:
            self.error_handler(e)
            return False

    def register(self, filename: str, pin: bytes, candidates: dict) -> bytes:
        """Registers the candidates.
        It stores the candidate list in a file.

        :param filename: The filename of the file in which the data is stored
        :param pin: The pin to be stored
        :param candidates: A dict containing the candidate details
        :returns: The candidate list
        """
        for key in candidates:
            candidates[key] = tuple(candidates[key])
        candidates[pin_key] = get_pin_hash(pin)
        try:
            with open(path(True, filename), "wb") as file:
                pickle.dump(candidates, file)
        except Exception as e:
            self.error_handler(e)
        self.candidates = candidates
        return candidates

    def read_candidates(self, filename: str) -> dict:
        """Reads the candidate list

        :param filename: The file name of the candidate list
        :returns: The the loaded data
        """
        self.vote_file_name = filename
        try:
            with open(path(True, filename), "rb") as file:
                candidates = pickle.load(file)
                self.candidates = candidates
                return candidates
        except Exception as e:
            self.error_handler(e)
            return {}

    def store_votes(self, pin: str, votes: list) -> bool:
        """Stores the list of vote data
        It iterates through votes, which should 
        contain the vote data generated by get_vote()
        The encrypted data is stored in a file in vote_path
        with its name being the encryption key. Just for fun.

        :param pin: The PIN used to encrypt the vote file
        :param votes: A list of vote data
        :returns: Whether the votes were stored successfully?
        """
        debug(votes)
        key = get_key(self.candidates[pin_key], pin)
        if not key:
            self.error_handler(PinException)
            return False
        if isfile(path(False, self.vote_file_name)):
            with open(path(False, self.vote_file_name), "rb") as file:
                debug("Store: Vote data found.")
                data = self.decrypt(key, file.read())
        else:
            debug("Store: Vote data not found. Creating new file.")
            data = {}
        for vote in votes:
            if vote in data:
                data[vote] += 1
            else:
                data[vote] = 1
        debug(data)

        with open(path(False, self.vote_file_name), "wb") as file:
            file.write(self.encrypt(key, data))
        return True

    def read_votes(self, pin: str) -> dict:
        """Reads and displays the data from a vote file
        
        :param pin: The PIN used to encrypt the vote data
        :returns: The vote data
        """
        key = get_key(self.candidates[pin_key], pin)
        if not key:
            self.error_handler(PinException)
            return False
        if isfile(path(False, self.vote_file_name)):
            data = self.decrypt(key, open(path(False, self.vote_file_name), "rb").read())
            debug("Read: Votes found: " + str(data))
        else:
            debug("Read: Votes not found")
            data = {}
        return data
